Целостность (integrity) - запрет неопределенных значений, PK, FK
Согласованность (consistency) - Конкурентное использование ресурсов корректными программами может привести к некорректным результатам. Тогда бд не согласована
Безопасность (security)

## Транзакция
Транзакция - конечный набор операций, который переводит согласованное состояние базы данных в согласованное, если
* все операции транзакции выполнены
* без помех со стороны других транзакций
* все операции предполагаются атомарными
* - формально проверить, согласована ли бд нельзя(

Последовательное выполнение транзакций гарантирует сохранение согласованности, но несовместимо с высокой производительностью системы

Система должна обеспечить сохранение согласованности при конкурентном выполнении транзакций, когда операции разных транзакций могут перемежаться

## Свойства ACID
Попытка формализации требований к транзакции
* Atomicity - атомарность - система дб действовать так, как будто транзакция либо была выполнена полностью, либо не оставила после себя никаких следов (сервер БД)
* Consistency - согласованность
* Isolation - изоляция, транзакции не могут видеть результатов других незавершенных транзакций (сервер БД)
* Durability - долговечность - те изменение, что успешно выполнены транзакцией, не могут быть потеряны. Первые три обеспечивают корректность выполнения, а этот - надежность хранения, восстановления после отказов

## Страничная модель базы данных
Введем еще одну модель, но попроще
* База данных: совокупность независимых и никак не связанных между собой элементов данных(Например, страницы базы данных, таблицы, строки таблиц, пары key-value, документы, …)
* Операции: чтение r и запись w
* Выполнение операции над элементом x данных в рамках транзакции i:r(i, x), w(i, x)
* Операция r(i, x) возвращает значение, записанное последней предшествующей операцией w(j, x) возможно, другой транзакции (i != j)

Транзакция - чатсично упорядоченное множество операций над данными

## Истории и расписания
* Все операции над одним элементом данных упорядочены
* Добавляется операция завершения: commit, abort
* Расписание - префикс истории - с каждой операцией содержатся все предшествующие

### Серийная история
* История называется серийной, если для любой пары транзакций все операции одной предшествуют всем операциям другой
* По определению транзакции, серийная история корректна

Если в системе доступны только такие транзакции, то оно будет идеально корректно и очень медленно. Это эталон выполнения транзакций

## Аномалии
Определим критерии корректности расписаний, какие некрректны? 
* Потерянное обновление: r1(x) rq(x) w1(x) w2(x) c1 c2   
w2 записывает, перезаписывая изменения первой
*  Несогласованное чтение: r1(x) r2(x) w1(x) w1(y) r2(y) c1 c2  
х считан до изменений,а у - после
* Грязное чтение: r1(x) w1(x)r2(x)a1c2  
Первая транзакция завершилась с ошибкой, а ее следы остались во второй

* ... Всего известно более 20 аномалий, они могут возникнут и при последовательном выполнении
* Не все аномалии можно представить в страничной модели (нужны
операции вставки и удаления)

### Виды транзакций
* Зафиксированные транзакции: в расписании есть операция фиксации (commit)
* Оборванные транзакции: в расписании есть операция обрыва (abort)
* Активные транзакции: в расписании не завершены

## Корректность и эквивалентность
* Истории (и расписания) эквивалентны, если они содержат совпадающие
множества операций и их выполнение дает совпадающие результаты (в некотором смысле, который будет уточняться).
* Расписание считается корректным, если оно эквивалентно серийному в смысле некоторого отношения эквивалентности

### Требования к критериям корректности
* Класс корректных расписаний должен быть по возможности широким
* Расписания, содержащие аномалии, не должны быть корректными
* Префикс корректного расписания должен быть корректным
* Критерий корректности должен быть эффективно проверяемым

### Семантики Эрбрана
синтаксически определяем семантику операций
* Операция чтения возвращает результат последней предшествующей операции
записи (неважно какой транзакции)  
H(ri(x)) = H(wj(x)) : wj(x) < ri(x), ∀wk(x)(wk(x) < ri(x) ⇒ wk(x) < wj(x))
* Значение, записываемое операцией записи, зависит от результатов операций чтения, предшествующих операции записи в этой транзакции, и определяется кодом приложеия (туда же входит пользовательский ввод):  
f_iy(H(ri (x1)), H(ri (x2),…)
* Начальное состояние базы данных записывается транзакцией 0, которая ничего не читает и записывает все элементы данных: H(w0(x) = f0x( )
* Можно еще сделать конечную, но она никогда не понадобится

### Семантики Эрбрана для расписаний
* Вселенная Эрбрана - это множество всех выражений (это рекурсивное определение)   
HU = {f ix(e1, . . . em), ek ∈ HU}
* Семантика Эрбрана для расписания: отображение множества операций
расписания во вселенную Эрбрана
* Другими словами: для каждого элемента данных определено выражение,
показывающее, какое значение этого элемента обрабатывает операция
* В каждом расписании (неявно) есть начальная транзакция

Возьмем операцию записи, после которой ничего нет. ЕЙ предшествует опреация чтения -  и т.д. Будем раскручивать так

### Эквивалентность 1. Сериализуемость по конечному состоянию - FSR

* Расписания эквивалентны по конечному состоянию, если после завершения этих расписаний семантики Эрбрана совпадают для всех элементов базы данных. При этом должно совпадать с результатом серийных расписаний.

* Допускается несогласованное чтение, если транзакция ничего не записывает

* Допускается грязное чтение

* Зачем такой критерий сериализуемости нужен?

### Эквивалентность 2. Сериализуемость по видимому состоянию - VSR

* Все транзакции в эквивалентных расписаниях должны видеть одинаковые состояния базы данных: требуется, чтобы семантики эмбрана в двух операциях совпадают для всех элементов, т.е. все транзакции запишут одни и те же значения

* Такая сериальзуемость сильнее, чем по конечному (мы требуем больеш, т.к. если конечно по всех состояниям, то и по видимым то же)

* Расписания эквивалентны по видимому состоянию если все операции чтения имеют совпадающие семантики Эрбрана

* Для эквивалентных по видимому состоянию семантики Эрбрана для операций записи тоже совпадают

* Критерий: расписания VS-эквивалентны тогда и толко тогда, когда их отношения Reads_from совпадают.

* Проверить эффективно vsr нельзя (np полная задача)

## Конфликты 
Конфликт - пара операций, которые:
* Обрабатывают один элемент базы данных (и, следовательно, упорядочены)
* Принадлежат разным транзакциям
* По крайней мере одна из операций является операцией записи.
Первая операция в конфликте предшествует второй.
Возможно, понадобится обозначение множества всех конфликтов расписания s: conf(s).

Избежать конфликтов невозможно, это просто пара операций.

### Эквивалентность 3. Сериализуемость по конфликтам

* Расписания s, s′ эквивалентны по конфликтам если (и только если)  
op(s) = op(s′) ∧ conf(s) = conf(s′)
* Расписание сериализуемо по конфликтам (CSR) если оно эквивалентно по
конфликтам серийному

* КРИТЕРИЙ CSR   
Граф (мультиграф) конфликтов G(s):
‣ Вершины - транзакции: trans(s),
‣ Дуги - конфликты, направленные

s ∈ CSR тогда и только тогда, когда G(s) не содержит контуров (замкнутый путь с учетом направления дуг)

Чтобы сделать расписание по графу без контуров - делаем его топсорт

=>Совпадающие множества конфликтов приводят к одинаковым графам конфликтов. Граф
конфликтов серийного расписания не содержит контуров

<=Топологическая сортировка графа без контуров создает эквивалентное серийное расписание

## Snapshot isolation 
Правила SI 
* STS(t), CTS(t) - Метки времени начала и конца транзакции

* E(t) = (STS(t), CTS(t)) - Интервал времени, в течение которого выполнялась транзакция

* RS(t), WS(t) - Множества элементов данных, которые читает и записывает транзакция

Правила SI:
➡SI1 Любая операция чтения в транзакции t возвращает значения,
зафиксированные до начала этой транзакции STS(t)

➡SI2 E(t1) ∩ E(t2) = ∅ ∨ WS(t1) ∩ WS(t2) = ∅

Расписание допустимо, если дял любой пары транзакций либо не пересекаются периоды, либо множества записываемых элементов. 

Расписание может быть допутсимо по Si, но не сериализуемо даже по самому узкому правилу (конечному состоянию). 
А может быть сериализовано по конфликту (самомц узкому классу) и не подходить под SI 

Si не содержится ни в одном классе эквивалетности

## Аномалии SI
Очень эффективна, используется в проме. Но имеет аномалии

пример: в больнице всегда дб хотя бы 1 врач. один ушел, второй ушел. Транзакции завершились и осталось 0 врачей. Это возможно, т.к. в транзакциях изменяются разгные данные.

* Несогласованная запись (Write skew):  
r1(x) r2(y) w1(y) w2(x) c1 c2
* Аномалия только читающей транзакции:  
r2(x) r2(y) r1(y) w1(y) c1 r3(x) r3(y) c3 w2(x) c2

### Сериализуемый SI
* Расписание принадлежит классу SSI тогда и только тогда, когда граф зависимостей ацикличен

* При выполнении правил SI могут
существовать только два типа
контуров

* Проверка на присутствие двух
соседних дуг может выполняться
очень быстро, но дает ложные
положительные резултаты

## Ослабленные критерии корректности в SQL
Проблема: транзакции ACID снижают пропускную способность, поэтому их ослабили

* READ UNCOMMITTED - нет вообще никаких ограничений (но все равно выполняется как read commited). Это бесплатно для постгрес, т.к. предыдущее значение все равно остается в субд
* READ COMMITTED - нельзя читать незафиксированные данные (запрещено "грязное чтение")
* REPEATABLE READ - повторное чтение в рамках той же транзакции дает тот же результат
* SERIALIZABLE - наиболее корректен, в постргрес сериализуемый si (обычно по конфликтам)