# Протоколы управления транзакции
Обеспечивает выполнения критериев корректности. Неявно предполагается,что система работает безотказно.

## Транзакционный сервер БД
Все эти компоненты стараются, как могут, но цели у них - разные

### 1. Менеджер транзакций
* Взаимодействует с приложением (клиентом): сообщает о результатах
* Назначает идентификаторы транзакций

### 2. Диспетчер (транзакций)
* Преобразует произвольный поток операций на входе в корректное расписание 

Может поступить с данными по разному сценарию:
1. Сразу отдает операцию на выполнение (это может привести к некоректному результату)
2. Придерживает операцию, пока не будет выполнено какое-то условие
3. Если операцию невозможно вписать в корректное расписание - она отвергается, транзакция обрывается, вынуждает менеджера транзакций сообщить об этом клиенту

Как оценить качество его работы? Метрики качества: 
* Пропускная способность (транзакций в секунду)
* Максимальное количесвто конкурентных транзакций 
* Частота обрывов (%)

Их значения зависят от:
* Среднего количество транзакций (количество операций)
* Количества данных, обрабатываемых каждой транзакцией
* Характеристик оборудования

Измерительные инструменты:
* TCP-C
* TCP-E

### 3. Менеджер данных
* Исполняет операции
* Организует выполнение операций ввода/вывода в соответствии со своими целями (может, чтобы рядом читались данные с жестких дисков. так что порядок операций может быть изменен им)

## Блокировки
Блокировка - механизм, позволяющий неявным образом синхронизировать работу транзакций

Бывают на чтение и запись. Несовместимы, когда устанавливают разное сосотояние. 

• Устанавливаются до и снимаются после любой операции p : pl(x) p(x)pu(x). При этом не гарантируют корректность. 

Блокировки отличаются от механизмов операционной системы (таких, как
mutex), т.к. блокируются элементы данных, а не процессы

## 1. Двухфазный протокол блокирования 2PL (1976)
До 1976 года протоколы тоже были, но кошмарные. До сих пор используется в непроизводительных системах

Правила двухфазного протокола:
* Транзакция (менеджер) может устанавливать блокировки на разные элементы данных в любом порядке
*  Попытка установки блокировки, несовместимой с уже имеющимися, задерживает выполнение транзакции до снятия несовместимого замка

* После снятия любой блокировки транзакция не имеет права устанавливать новые

• Фаза 1: Блокирование

• Фаза 2: Разблокирование

* При завершении транзакции все блокировки снимаются

### Проблема тупиков (deadlock ~ смертельные объятия)
r1(x) r2(y) w2(x) w1(y) - взаимное ожидание никогда не закончится

Распознавание тупиков: граф ожиданий (WFG):
* вершины - транзакции, 
* дуги: из ожидающей транзакции в транзакцию, установившую несовместимую
блокировку

Тупик имеет место тогда и только тогда, когда граф ожиданий содержит контур. Распознавание тупиков по времени ожидания применяется, но может быть ошибочным.

### Решение 
Выбор жертвы (транзакции, которая будет оборвана) является разновидностью задачи предсказания будущего:
* Случайно выбранная транзакция, попавшая на контур в WFG
* Самая старая транзакция (возможно, установившая много блокировок)
* Последняя (по времени) транзакция (не очень много работы будет
потеряно)
* Максимальное количество входящих дуг (ожидающих транзакций)

Это все эвристики, как правильно - непонятно

### профилактика тупиков
Дают большую долю оборванных транзакций, чем при разрешении тупиков

...

## S2PL
2PL не предотвращает аномалию грязного чтения

Strict 2PL (S2PL): блокировки на запись удерживаются до завершения транзакции  
Используется во многих системах как реализация SERIALIZABLE. Не производительный!

## SS2PL
SS2PL - все блокировки удерживаются до завершения
транзакции. Все хорошо с корректностью, но корректных расписаний очень мало. Не производительный! Результаты близки к серийному.

## Протокол для деревьев WTL
* Предполагается, что база данных имеет структуру дерева
* Все блокировки на один элемент данных несовместимы
* WTL1: Для блокировки любого элемента данных, кроме корня, транзакция
должна иметь блокировку на родительский элемент данных
* WTL2: Снятая блокировка не может быть установлена повторно
* Протокол свободен от тупиков
* Не применяется (и, вероятно, никогда не применялся) на практике

## Протокол на основе меток времени TO (timastamp ordering)
sts(ti) метка времени начала, должна быть уникальна и присваивается
каждой транзакции

• Правила протокола TO:
• Если операции pi(x), qj(x) находятся в конфликте, то
sts(ti) < sts(tj) ⟹ pi(x) < qj(x)

Транзакция не имеет право записывать элемент данных, который был записан более поздней транзакцией 

И не имеет право записывать то, что было прочитано более полздней транзакцией

• Корректность: значения меток вдоль пути возрастают, поэтому контуры
невозможны

+ Совмем нет ожиданий и блокировок
+ В распределенной системе метку времени можно проверять локально, можно не синхронизировать
- Большое количество обрывов (если операцию нельзя выполнить - то её нельзя выполнить "подождав", нужно сразу обрывать)

### Реализация ТО
Для каждого элемента данных хранятся две метки времени:
* Метка чтения = sts последней транзакции, выполнившей
* Метка записи = sts последней транзакции, записавшей x
๏Правила выполнения операций;
• Если то обрывается

• Если то обрывается
๏Для того, чтобы менеджер данных не переставлял операции, необходимо устанавливать
блокировки на время выполнения операции (но не больше)

## SI
Для каждой транзакции строится период вермени выполнения и набор данных, для двух транзакций они выполнятся не должны (только для записи, чтение вообще не контролируется)
### Реализация SI на основе блокировок (на запись)
• Формальное определение правил:E(t1) ∩ E(t2) = ∅ ∨ WS(t1) ∩ WS(t2) = ∅
Правила установки блокировок:
• Применяются только блокировки на запись

• Если tj пытается установить блокировку, несовместимую с блокировкой ti то tj задерживается до завершения ti, если ti фиксируется, то tj обрывается (first commited wins)

• Новые знания ачения делаются доступными для других транзакций во время
фиксации

+ Используется во всех высокопроизводительных субд

### Многоверсионность 
БД короткое вермя хранит сразу нельсоклько версий данных, чтобы работать с транзакциями, которые "немного опоздали", чтобы она могла прочитать подходящую версию данных.

Каждое приложение видит только одну версию БД

Позволяет повысить количество параллельно выполняемых транзакций