# Алгоритмы алгебраических операций

## Основные статистические характеристики
* R,S – аргументы операций (таблицы, отношения)
* Tr – количество объектов (строк таблицы)
* Br – количество блоков, занимаемых коллекцией (таблицей)
* Lr –средняя длина (в байтах) строки таблицы
* t – кардинальность результата операции
* Ia – количество различных значений атрибута

## Масштабируемость
Возможна по одной из конфигураций 
* пропускная способность
* время отклика

## Алгоритмы выборки данных
* Последовательный просмотр таблиц (Heap scan)   
Время работы всегда линейно. Для некоторых устройств последовательное чтение быстрее. Также ускоряется через последовательное чтение.
* Поиск по индексу (index range scan) с последующим доступом к таблице по адресам блоков данных
Индекс д.б. для одного из поля в select. Время поиска логарифмически зависит от объема данных.   
Эффективен, если селиктивность мала. Если нужно выбрать почти все данные из таблицы - то через индекс их искать медленнее, чем линейно. Опять же, для обычной памяти. 
*  Выборка данных только из индекса (index only scan)    
Если индекс есть для всех колонок. БЫстрее всегда, но не всегда применим.

* Построение битовой шкалы блоков по нескольким индексам с последующим
просмотром помеченных блоков (bitmap heap scan)

## Селективность 
доля записей, уддовлетворяющих уловию фильтрации и соединения по отношению к общему количеству записей

## Сложность декартова произведения 
Не может быть меньше, чем размер результата (который нужно вычислить)

* Tuples: TRTS
* Blocks: BRTS + TRBS

 Эта оценка снизу достигается простым алгоритмом вложенных циклов

## Алгоритм вложенных циклов
* Циклы на уровне строк таблиц

* Циклы на уровне блоков   
1. Асимметричный - Меньший аргумент обрабатывается внешним циклом
2. Оптимальная стратегия при ограниченной оперативной памяти  
2.1. Все доступные страницы, кроме одной, заполняются блоками первого
аргумента   
2.2 Циклы на 4 уровнях: два внешних по блокам, внутренние по строкам

* Хорошо распараллелировается. Вычисление произведения на P устройствах:
1. Фаза 1: распределение  
 Сегменты первого аргумента (равного размера) рассылаются
исполнителям
2. Фаза 2: вычисление результата 
* Второй аргумент полностью посылается на все исполнители
* На каждом исполнителе выполняется локальный алгоритм вложенных
циклов
* Время вычисления сокращается в P раз

т.е. время работы (производительность по веремни отклика) масштабируется идеально 

## Оценка размера результата эквисоединения (join)
соединение - прямое соединение с фильтрацией

эквисоединение - соединение по равенству атрибутов

Предполагается равномерность распределения значений атрибута А:каждое
значение 
* встречается в Tr/Ia строках R
* встречаетя в Ts/IA строках S

Оценка размера результата:
 TR⋈S = (TrTs)/Ia

Ia - количество атрибутов


## Алгоритм соединения на основе слияния
* Аргументы должны быть упорядочены по ключу соединения
* Однократный проход по значениям атрибута соединения
* Вложенные циклы для каждого значения атрибута соединения (требуется вычисление произведения)
* Результат тоже упорядочен - такой алгоритм выгоден, если много промежуточных результатов 

Тоже может быть распараллелен и хорошо масштабируется 

## Соединение на основе хеширования 

1. Фаза распределения (Build)
• Первый (меньший) аргумент распределяется по корзинам с
применением функции хеширования по атрибуту соединения

Фаза проверки (Probe):
• Строки второго аргумента направляются в корзины хеширования

• Каждая строка обрабатывается в
пределах корзины 
Если две строки в разных корзинах - то и их результат в ответ не входит

Стоимость линейная по входным аргументам. Хорош, когда много данных

Распараллеливание на первой фазе

## Гибридный hash join

## Симметричный hash join
Совмещает фазы build и probe

Можно получать результаты для некоторых строк до окончания полного соединения 

## Многоместные операции соединения 

## The Skew
Соединение на оснве хеширования эффективно, если распределения
равномерны  
Результаты соединения могут быть распределены неравномерно даже при
равномерном распределении входных аргументов  
Для устранения отрицательного влияния на производительность
необходимо:
* Обнаруживать скос во время выполнения операции
* Динамически перераспредлять нагрузку

##