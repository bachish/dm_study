## Ограничения целостности (Primary key и Foreign key только для этого!!!)
Типы:  

* NOT NULL запрещает появление неопределенных значений атрибута.

* UNIQUE задает группу атрибутов, которые образуют возможный ключ отношения, т. е. для любых двух строк таблицы значения хотя бы одного из атрибутов, входящих в возможный ключ, должны различаться. Очень часто
такое ограничение состоит всего из одного атрибута.  
Допускает неопределенные

* PRIMARY KEY задает атрибут или группу атрибутов, которые используются как
первичный ключ отношения. Обычно такое ограничение определяется
для атрибутов, составляющих идентификатор сущности, и поэтому обычно эти атрибуты считаются неизменяемыми, однако язык SQL допускает
изменение значений атрибутов первичного ключа. Очень часто первичный ключ состоит только из одного атрибута, хотя язык SQL позволяет
создавать составные первичные ключи.
Важное отличие уникального ключа от первичного состоит в том, что для
атрибутов, входящих в уникальный ключ, могут допускаться неопределенные значения (NULL), а для атрибутов первичного ключа — нет.

* FOREIGN KEY задает группу атрибутов, значения которых должны совпадать со
значениями атрибутов первичного или уникального ключа другого отношения, указанных в этом ограничении. Таким образом, это ограничение
задает бинарные связи между сущностями.

* CHECK  произвольное условие на значения одного или нескольких атрибутов в одной строке таблицы.

## Операторы манипулирования 

Любой результата - это отношение  
Таблица из одной строки и одной колонки неотличима от скаляра

delete

update

## Псевдоним
select f.flight_no as number

## Подзапросы
(select city from airport where...) as number  
этот запрос все равно превратится при исполнении в соединение

!! Если в подзапросах одинаковые запросы - они могут быть не найдены при оптимизации и выполнены дважды
```sql
where stud_id (not) in (select id from ...where...)

where (not) exist (select . from .. where ...)
```
## Представления 
подзапросы, записанные в бд. Могут быть использованы наравне с таблицами.
Подставляются в запрос, оптимизируются, и только потом вычисляютя (вместе с основным запросом)

```sql
create view airports as select ... from ...;
```

CTE:
```sql
with sub_expr as ()  
```
Используются для рекурсии

## Вывод результатов модификации
```sql
insert into ... select ... returning ...;
update  ... set ... where ... returning ...;
delete from ... where ... returning ...;
```
Можно применять в именованных подзапросах, меняя одновременно несколько таблиц

## Агрегирование (группировка)
Фильтруем результат агригирующей функции используя having

## Выразительные средства
* условные выражения отсутствуют, т.к. язык декларативный, но есть такое
```sql
(case when p1 then ... when p2 then ... else ... end)
```
## Дубликаты
* Объект - это истинное выражение, от его повторения оно более истинным не станет
* А если объекты не отличимы? Тогда их нельзя пересчитать не выходя за рамки модели (например, вводя поле "количество")
* Результат реляционной алгебры отличен при дублировании
## Алгебраические операции
Докажите, что sql реляционный: выразите на нем все операции алгебры

### Селекция
R(x, y): -Courses(x, y, z) and y > 8  
R(x.title, x.credits): -x in courses and x.credits > 8   
```sql   
select title, credits from courses where credits > 8
```
### Проекция 

### Произведение
select * from courses, exams;

### Соединение (произведение + фильтрация)
```sql 
select * from courses, exams  
where courses.course_no = exams.course_no
```
 (можно и join, это же декларативно и считается одинаково оптимально)

Находит пары взаимосвязанных объектов, делает явными неявными связи  
Эффективнее, чем произведение

### Левое внешнее соединение 
Если условие в where, то значения с bull будут лодными и откинутся

## Безопасные запросы в SQL 
гарантия, что не появится дубликатов
* Все таблици имеют ПК
* distinct
* group by в запросе гарантирует уникальность строк результата
* соединение по уникальному ключу тоже

## программирование запросов: thinking sets
* Определить (содержательно), какие элементы составляют множество строк
результата
* Построить предложения FROМ и, возможно, GROUP BY (получить ключ результата)
* Предложение WHERE (выбрать нужные строки)
* Выражения, определяющие колонки результата
* Возможно, применять эти шаги рекурсивно для построения подзапросов

