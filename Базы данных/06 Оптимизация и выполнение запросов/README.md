## Стадии обработки запроса на сервере базы данных

1. Компиляция SQL, получение алгебраического выражения (начального логического
плана)
2. Переписывание логического плана (приведение к каноническому виду)
3. Подстановка параметров для параметризованных запросов
4. Оптимизация: перестройка плана и назначение физический операций (алгоритмов)  
Получаем дерево запросов -> оптимизируем (изменяем структуру дерева, выбираем как вполнять операции)

Нужно определить:
* Пространство эквивалентных планов
* Функцию стоимости
5. Выполнение запроса - интерпретация плана его выполнения 

## Explain
* seq scan - последовательный просмотр
* Bitmap Index Scan - 

## пространства планов
Есть два источника для их получения (они эквивалентны по результату, но не по сложности): алгеюраические тождества и различные реализации конкретных операций


## Целевые функции (для оптимизации)
Внешние:
* Пропускная способность (?)
* Время отклика
- Среднее или максимальное
- Полный результат или первая строка

Технические:
* Количество обращений к дискам
* Суммарное процессоров время
* Общее время выполнения
* Комбирирование критериев

## Интерпретация планов
* Каждая операция передает результаты выполнения в слудущую операцию по мере
их получения
* Промежуточные результаты выполнения запроса нигде не сохраняются
* Стоимость передачи данных между операциями пренебрежимо мала по
сравнению со стоимостью операций, это неверно при работе по сети. В этом случае в план включается операция копирования
* Стоимость выполнения плана оценивается суммой стоимостей входящих в него
операций

## Методы оптимизации
* Алгоритмы: точные или приближенные, но ведущие к нахождению оптимального плана
* Правила преобразования запросов, не ухудшающие стоимость
* Эвристики: - обычно полезны, но могут приводить к потере оптимального плана
* Функции и модели стоимости

### Сокращение пространства планов
1. Применение преобразований, заведомо не ухудшающих стоимость
2. По возможности раннее выполнение операций, сокращающих размеры обрабатываемых данных
3. Исключение заведомо неоптимальных планов
4. Исключение планов, в которых вычисляется декартово произведение
5. Применение эвристик, ограничивающих вид получаемого плана
6. Ограничение на вид дерева

### Алгоритмы оптизации
Те, что ниже - работают с SPJ запросами
* Запросы, содержащие только фильтрацию (Select), проекцию (Project) и соединение (Join)
* Класс SPJ содержит значительную часть встречающихся на практике запросов
* Применимы все классические алгоритмы оптимизации
* Для запросов общего вида оптимизаторы
- Применяют расширенные наборы преобразований и дополнительные эвристики
- Разбивают запрос на SPJ части, которые оптимизируются по отдельности

Стратегии: 
* План переписывается так, чтобы исключить подзапросы
* Операции фильтрации и проекции, сокращающие размеры, перемещаются как
можно ближе к листьям (операциям выборки хранимых данных)
* Операции фильтрации и проекции, которые нельзя переместить к листьям,
совмещаются с предшествующими операциями соединения (выполняются “на лету”)
* Описанные выше действия сводят задачу оптимизации к задаче выбора дерева
операций соединения05

Рекуррентное правило оптимальности  
Любое поддерево оптимального плана - оптимально для этого подзапроса (иначе мы бы улучшили его)

### Алгоритм динамического программирования
1. Построить оптимальный план выборки данных для каждой таблицы, встречающейся в запросе

2. По каждому частичному плану длины k построить план длины k+1
* Построить соединение с каждой таблицей, еще не включенной в подплан длины k
* В каждом множестве эквивалентных планов длины k+1 выбрать один
оптимальный (наименьшей стоимости), остальные исключить

3. Повторять шаг 2 до тех пор, пока не будут включены все таблицы

* Высокая сложность в худшем случае по памяти и по времени
* Применим для запросов, содержащих не более 11-12 операций соединения
* Если ограничить выбор алгоритмов соединения (только вложенные циклы), то
сложность становится полиномиальной

### Жадный алгоритм
Выбирается на каждом шаге один наилучший подплан

Очень плох, в промышленности не используется 

### Итеративное динамическое программирование 
* Комбинация исчерпывающего динамического программированияия и жадного

• Вариант 1: Начинает работу как исчерпывающий, после достижения порога по
времени или по памяти делает шаг, как жадный, затем продолжает, как
исчерпывающий

• Вариант 2: Работает, как жадный и затем делает локальные перестройки
исчерпывающим алгоритмом

### Трансформационные алгоритмы (приближенные)

Пространство планов представляется графом
* Вершины - планы (полные)
* Дуги - элементарные преобразования
- Применению алгебраического
тождества
- Замене алгоритма на
эквивалентный

1. Случайно выбираем план
2.  Переход по дуге, улучшающей
оценку плана (до локального
минимума)
3. Поиск продолжается с другого
случайно выбранного плана
4. Варианты: отжиг, стохастический
спуск, . . .
5. Генетические алгоритмы

## Проблемы

* Высокая сложность исчерпывающих алгоритмов  
* Неточности моделей стоимости (оценки кардинальности)  
* Неточности целевой функции   
* Ограниченность класса запросов (SPJ)  
* Приближенные алгоритмы снизу вверх (линеаризация)  
* Расширение класса алгебр (включение агрегирования)
* Применение методов машинного обучения для решения задачи оптимизации запросов (слишком большое время для обучнеия и зависимость от структуры бд или новых запросов)
- На основе данных (оценки кардинальности)
- На основе запросов (оценки стоимости)